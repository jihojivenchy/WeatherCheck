# OpenWeather API를 이용한 날씨 앱

## 구현 영상
<img src = "https://github.com/jihojivenchy/WeatherCheck/assets/99619107/e57f07ed-9368-4036-907b-885547f6568a" height = 600>
용량 문제로 저화질일 수 있다는 점 양해부탁드립니다:)

<br>

### 배경 날씨를 적용한 경우 영상
<img src = "https://github.com/jihojivenchy/WeatherCheck/assets/99619107/579faa1c-2e19-47d5-b884-eecea8683c1b" height = 600>
날씨 상태에 따라 배경 이미지를 교체할 수 있지만, 디자인 상 완벽하지 않아 사용하지 않았습니다.

<br>

# 아키텍처
1. 클린아키텍처
2. MVVM
3. 코디네이터 패턴

<br>

## 클린 아키텍처
<img alt="Clean-architecture" src="https://github.com/bridge0813/bridge-ios/assets/65343417/716863c5-c30d-4785-b7eb-5706775be58d">

### 사용 이유
- 각 객체의 명확한 책임 분리를 통해 유지보수성을 향상시키기 위해 적용했습니다.
- 오버 엔지니어링인 점은 알지만, 과제 특성 상 다양한 접근을 보여드리기 위해 적용했습니다.

### 결과
- 각 객체의 책임을 명확하게 분리함으로써 유지보수성 및 개발 생산성이 향상되었습니다.
- Mock 리포지토리를 이용하여 네트워크 의존성 없이 UI 테스트를 할 수 있습니다.

<br>

## 코디네이터 패턴
### 사용 이유
- UI 로직과 화면 전환 로직을 분리하여 객체의 책임을 명확하게 하기 위해 적용했습니다.

### 결과
- UI 로직과의 분리를 통해 Massive한 뷰 컨트롤러를 방지할 수 있습니다.
- 불필요한 인스턴스의 중복 생성을 방지할 수 있습니다

<br>

## Main 화면 구성
- UIScrollView를 기반으로 하여, 각각의 데이터를 보여주는 화면 단위를 UIView 컴포넌트로 나누어 구현했습니다.
- 만약 재사용되는 뷰나 더 많은 영역이 필요했다면, 컬렉션 뷰를 통해 구현하는 것을 고려했을 것 같습니다.

<br>

## Search 화면 구성
- UISearchBar와 UITableView로 구성하였습니다.

<br>

## 데이터 계층 설명
### APIKeyManager
- APIKeyManager는 저장되어 있는 APIKey를 가져오는 객체입니다.
- APIKey를 외부로 노출하지 않도록 .xcconfig와 gitignore를 이용하여 보안을 유지했습니다.
- .xcconfig를 이용하면 API 키를 코드에서 분리하며, 디버그나 릴리스와 같은 환경 별로 다른 설정 파일을 사용하여 손쉽게 관리할 수 있습니다.
<br>

### DTO
- 데이터 전송을 위한 객체로 사용되어, 엔티티와의 직접적인 의존성을 제거해줍니다.
<br>

### Endpoint
- HTTP 구조에 맞게 URLRequest를 정의하는 프로토콜입니다.
- 필요한 요청에 맞게 Endpoint를 채택하여 구현합니다.
- 불필요한 요소들이 있지만, API 통신을 위해 다음과 같은 구조를 설계할 수 있다는 점을 어필했습니다.
<br>

### NetworkService
- 단일 책임에 맞게 네트워킹만을 수행하는 객체입니다.
- 아쉬운 점은 Almofire를 활용하여 더 나은 코드를 설계하지 못한 것입니다.
- Almofire에 대해 더 학습하여 적용할 수 있도록 노력하겠습니다.
<br>

### BundleFileService
- 단일 책임에 맞게 파일에 접근하여 데이터를 조회하는 객체입니다.
- 리포지토리에서 수행할 수 있는 기능이지만, 명확한 책임 분리를 위해 따로 구현했습니다.
- city.json 파일에 접근하여 데이터를 가져옵니다.
<br>

### Repository
- 네트워크 서비스 등을 이용하여 필요한 데이터를 조회하고, 조회된 데이터를 가공하여 도메인으로 보내주는 역할을 수행합니다.
- 날씨를 조회하고, 날씨 데이터를 가공하는 역할을 수행합니다.

<br>

# 고민했던 부분들
## 1. 원활한 검색
- 검색화면에서 더 나은 사용자 경험을 위해 각 문자열에 포함되는 도시 리스트를 조회하도록 구현했습니다.
- 하지만 워낙 방대한 양의 자료를 다루다보니 UI의 버벅거림이 생기는 문제가 발생했고, 이를 해결하기 위해 다음과 같은 방법을 적용했습니다.
<br>

### Debounce
- RxSwift 오퍼레이션 중 하나인 debounce를 적용 일정 시간 내에 연속되는 이벤트를 제거하여 효율성을 높였습니다.
- 검색 특성 상 키보드 글자마다 조회를 시도하는 것보다 특정 시간 제한을 두어 연속되는 이벤트를 제거하는 것이 효율적입니다. 
<br>

### 백그라운드 처리
- 조회한 도시 리스트를 디코딩 및 필터링 하는 과정을 백그라운드 스레드에서 수행할 수 있도록 했습니다.
- 이를 통해 UI의 영향을 최소화할 수 있습니다.
<br>

### 조회 데이터 제한
- 너무 방대한 양의 데이터는 사용자에게도 불필요하기 때문에 prefix를 이용하여 갯수를 20개로 제한하여 반환하도록 구현했습니다.

<br>

## 2. 코디네이터 객체의 명확한 책임
- 요구사항은 메인 화면에서 검색 화면을 presnet 하고, 검색 화면에서 조회된 결과를 다시 메인 화면에 가져와야 합니다.
- 이 과정에서 검색 화면에서 조호된 결과를 메인 화면과 연결하여 이벤트 처리를 하는 부분이 애매했습니다.
- 이를 위해, 여러 가지 해결책을 고려해보았습니다.
<br>

### 팝업 뷰 이용하기
- 따로 뷰 컨트롤러를 구현하지 않고, 뷰 컴포넌트로 구현하여 MainViewModel 에서 같이 처리할 수 있도록 구현하기
- 하지만 도시 리스트 검색이라는 데이터 계층의 의존이 필요하기 때문에 뷰 컨트롤러와 뷰 모델을 생성하는 것이 적절하다고 판단했습니다.
<br>

### 코디네이터에 참조 객체를 생성하기
- 코디네이터에서 새로운 참조 객체를 구현하여 메인 화면에서는 이를 바인딩하고, 검색 화면에서는 이벤트 방출을 할 수 있도록 구현하기
- 이 방법은 간단하지만, 코디네이터의 화면 전환이라는 역할에서 벗어나는 책임을 맡는다고 판단되어 수정했습니다.
<br>

### 같은 뷰 모델 사용하기
- 검색 화면은 결국 메인 화면에 종속되어 있기 때문에 같은 뷰 모델 객체를 사용하여 구현하기
- 더 고려해봐야 할 것 같아 사용하지 않았습니다.
<br>

### 최종 구현
- 메인 화면에서 검색된 결과를 받을 수 있는 참조 객체를 구현하고, 화면 전환 시 검색 화면에도 전달하여 이벤트를 받아볼 수 있도록 구현
- 코디네이터의 화면 전환 책임도 지키며, 이벤트를 전달받는 깔끔한 방법이라고 생각되어 적용했습니다.
<br>

## 3. 날씨 데이터 가공하기
- 조회한 날씨 데이터를 화면에서 보여주기 위한 엔티티로 변환하는 과정
- 데이터는 5일 동안 3시간 간격으로 주어지는데, 여기서 일 간격으로 5일 간의 날씨 평균 데이터를 가공해야 했습니다.
<br>

### 해결
1. 먼저 해싱 알고리즘을 기반으로 한 Dictionary를 이용하여 각 일별로 날씨 데이터를 나누었습니다.
2. 일별로 나누어진 데이터를 날짜 순서대로 정렬했습니다.
3. 각 일별 데이터를 순회하면서, 최소 온도의 평균, 최고 온도의 평균을 계산하여 엔티티를 위한 데이터를 구현했습니다.

















